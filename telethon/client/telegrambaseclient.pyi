import abc
import asyncio
import logging
import pathlib
from .. import helpers as helpers, version as version
from .._updates import ChannelState as ChannelState, Entity as Entity, EntityType as EntityType, MessageBox as MessageBox, SessionState as SessionState
from ..crypto import rsa as rsa
from ..extensions import markdown as markdown
from ..network import Connection as Connection, ConnectionTcpFull as ConnectionTcpFull, MTProtoSender as MTProtoSender, TcpMTProxy as TcpMTProxy
from ..sessions import MemorySession as MemorySession, SQLiteSession as SQLiteSession, Session as Session
from ..tl import functions as functions, types as types
from ..tl.alltlobjects import LAYER as LAYER
from .telegramclient import TelegramClient as TelegramClient
from _typeshed import Incomplete

DEFAULT_DC_ID: int
DEFAULT_IPV4_IP: str
DEFAULT_IPV6_IP: str
DEFAULT_PORT: int

class _ExportState:
    def __init__(self) -> None: ...
    def add_borrow(self) -> None: ...
    def add_return(self) -> None: ...
    def should_disconnect(self): ...
    def need_connect(self): ...
    def mark_disconnected(self) -> None: ...

class TelegramBaseClient(abc.ABC, metaclass=abc.ABCMeta):
    __version__: Incomplete
    session: Incomplete
    api_id: Incomplete
    api_hash: Incomplete
    def __init__(self, session: str | pathlib.Path | Session, api_id: int, api_hash: str, *, connection: type[Connection] = ..., use_ipv6: bool = False, proxy: tuple | dict = None, local_addr: str | tuple = None, timeout: int = 10, request_retries: int = 5, connection_retries: int = 5, retry_delay: int = 1, auto_reconnect: bool = True, sequential_updates: bool = False, flood_sleep_threshold: int = 60, raise_last_call_error: bool = False, device_model: str = None, system_version: str = None, app_version: str = None, lang_code: str = 'en', system_lang_code: str = 'en', loop: asyncio.AbstractEventLoop = None, base_logger: str | logging.Logger = None, receive_updates: bool = True, catch_up: bool = False, entity_cache_limit: int = 5000) -> None: ...
    @property
    def loop(self) -> asyncio.AbstractEventLoop: ...
    @property
    def disconnected(self) -> asyncio.Future: ...
    @property
    def flood_sleep_threshold(self): ...
    @flood_sleep_threshold.setter
    def flood_sleep_threshold(self, value) -> None: ...
    async def connect(self) -> None: ...
    def is_connected(self) -> bool: ...
    def disconnect(self): ...
    def set_proxy(self, proxy: tuple | dict): ...
    @abc.abstractmethod
    def __call__(self, request, ordered: bool = False): ...
